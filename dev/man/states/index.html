<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>States and channels · QuantumInformation.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="QuantumInformation.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">QuantumInformation.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../quickstart/">Quickstart</a></li><li><a class="tocitem" href="../vectors/">Linear algebra in Julia</a></li><li class="is-active"><a class="tocitem" href>States and channels</a><ul class="internal"><li><a class="tocitem" href="#States"><span>States</span></a></li><li><a class="tocitem" href="#Non-standard-matrix-transformations"><span>Non-standard matrix transformations</span></a></li><li><a class="tocitem" href="#Channels"><span>Channels</span></a></li><li><a class="tocitem" href="#refs_sc"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../functionals/">Functionals</a></li><li><a class="tocitem" href="../measurement/">Measurement</a></li><li><a class="tocitem" href="../random/">Random quantum objects</a></li></ul></li><li><a class="tocitem" href="../../lib/QuantumInformation/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>States and channels</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>States and channels</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/iitis/QuantumInformation.jl/blob/master/docs/src/man/states.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="States-and-channels"><a class="docs-heading-anchor" href="#States-and-channels">States and channels</a><a id="States-and-channels-1"></a><a class="docs-heading-anchor-permalink" href="#States-and-channels" title="Permalink"></a></h1><p>In this and the following sections we will denote complex Euclidean spaces <span>$\mathbb{C}^d$</span> with <span>$\mathcal{X}$</span>, <span>$\mathcal{Y}$</span>, <span>$\mathcal{Z}$</span> etc. When needed the dimension of a space <span>$\mathcal{X}$</span> will be denoted <span>$\mathrm{dim}(\mathcal{X})$</span>. The set of matrices transforming vectors from <span>$\mathcal{X}$</span> to <span>$\mathcal{Y}$</span> will be denoted <span>$\mathrm{L}(\mathcal{X}, \mathcal{Y})$</span>. For simplicity we will write <span>$\mathrm{L}(\mathcal{X}) \equiv \mathrm{L}(\mathcal{X}, \mathcal{X})$</span>.</p><h2 id="States"><a class="docs-heading-anchor" href="#States">States</a><a id="States-1"></a><a class="docs-heading-anchor-permalink" href="#States" title="Permalink"></a></h2><p>By <span>$|\psi\rangle\in\mathcal{X}$</span> we denote a normed column vector. Notice that any <span>$|\psi\rangle$</span> can be expressed as <span>$|\psi\rangle=\sum_{i=1}^{n} \alpha_i |i\rangle$</span>, where <span>$\sum_{i=1}^{n} |\alpha_i|^2=1$</span> and the set <span>$\{|i\rangle\}_{i=1}^{n}$</span> is the computational basis.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ket(1,2)</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{ComplexF64}:
 1.0 + 0.0im
 0.0 + 0.0im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (1/sqrt(2)) * (ket(1,2) + ket(2,2))</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{ComplexF64}:
 0.7071067811865475 + 0.0im
 0.7071067811865475 + 0.0im</code></pre><p>According to common academic convention, we count the indices of states starting from one. Following the standard Dirac notation the symbol <span>$\langle\psi|$</span> denotes the row vector dual to <span>$|\psi\rangle$</span>. Therefore <span>$|\psi\rangle=\langle\psi|^\dagger$</span>, where the symbol <span>${}^\dagger$</span> denotes the Hermitian conjugation.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; bra(2,3)</code><code class="nohighlight hljs ansi" style="display:block;">1×3 adjoint(::Vector{ComplexF64}) with eltype ComplexF64:
 0.0-0.0im  1.0-0.0im  0.0-0.0im</code></pre><p>The inner product of <span>$|\phi\rangle, |\psi\rangle \in \mathcal{X}$</span> is denoted by <span>$\langle\psi|\phi\rangle$</span> and the norm is defined as <span>$\||\phi\rangle\|=\sqrt{\langle\phi|\phi\rangle}$</span>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ψ=(1/sqrt(2)) * (ket(1,2) + ket(2,2))</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{ComplexF64}:
 0.7071067811865475 + 0.0im
 0.7071067811865475 + 0.0im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ϕ=(1/2) * ket(1,2) + (sqrt(3)/2) * ket(2,2)</code><code class="nohighlight hljs ansi" style="display:block;">2-element Vector{ComplexF64}:
                0.5 + 0.0im
 0.8660254037844386 + 0.0im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ϕ&#39;*ψ</code><code class="nohighlight hljs ansi" style="display:block;">0.9659258262890682 + 0.0im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sqrt(ϕ&#39;*ϕ)</code><code class="nohighlight hljs ansi" style="display:block;">0.9999999999999999 + 0.0im</code></pre><p>The form <span>$|{\psi}\rangle\langle{\phi}|$</span> denotes outer product of <span>$|{\psi}\rangle$</span> and <span>$\langle{\phi}|$</span> from <span>$\mathrm{L}(\mathcal{X})$</span>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ketbra(2,3,4)</code><code class="nohighlight hljs ansi" style="display:block;">4×4 Matrix{ComplexF64}:
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  1.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im
 0.0+0.0im  0.0+0.0im  0.0+0.0im  0.0+0.0im</code></pre><p>Specifically, <span>$|{\psi}\rangle\langle{\psi}|$</span> is a rank-one projection operator called as <em>pure state</em>. Generally, any <a href="https://en.wikipedia.org/wiki/Qubit"><em>quantum state</em></a> <span>$\rho$</span> can be expressed as <span>$\rho=\sum_{i=0}^n q_i |i\rangle\langle i|$</span>, where <span>$\sum_{i=0}^n q_i=1$</span>. Notice that <span>$\rho$</span> is a trace-one positive semi-definite linear operator <em>i.e.</em>: <span>$\rho=\rho^\dagger$</span>, <span>$\rho\geq 0$</span> and <span>$\mathrm{tr}{\rho}=1$</span>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; proj(ψ)</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{ComplexF64}:
 0.5+0.0im  0.5+0.0im
 0.5+0.0im  0.5+0.0im</code></pre><p>For convenience, the <strong>QuantumInformation.jl</strong> library provides the implementations of maximally mixed, maximally entangled and Werner states.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; max_entangled(4)</code><code class="nohighlight hljs ansi" style="display:block;">4-element reshape(::LinearAlgebra.Diagonal{ComplexF64, Vector{ComplexF64}}, 4) with eltype ComplexF64:
 0.7071067811865475 + 0.0im
                0.0 + 0.0im
                0.0 + 0.0im
 0.7071067811865475 + 0.0im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; max_mixed(4)</code><code class="nohighlight hljs ansi" style="display:block;">4×4 LinearAlgebra.Diagonal{Float64, Vector{Float64}}:
 0.25   ⋅     ⋅     ⋅
  ⋅    0.25   ⋅     ⋅
  ⋅     ⋅    0.25   ⋅
  ⋅     ⋅     ⋅    0.25</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; werner_state(4, 0.4)</code><code class="nohighlight hljs ansi" style="display:block;">4×4 Matrix{ComplexF64}:
 0.35+0.0im   0.0+0.0im   0.0+0.0im   0.2+0.0im
  0.0+0.0im  0.15+0.0im   0.0+0.0im   0.0+0.0im
  0.0+0.0im   0.0+0.0im  0.15+0.0im   0.0+0.0im
  0.2+0.0im   0.0+0.0im   0.0+0.0im  0.35+0.0im</code></pre><h2 id="Non-standard-matrix-transformations"><a class="docs-heading-anchor" href="#Non-standard-matrix-transformations">Non-standard matrix transformations</a><a id="Non-standard-matrix-transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Non-standard-matrix-transformations" title="Permalink"></a></h2><p>We will now introduce reshaping operators, which map matrices to vectors and vice versa. We start with the mapping <span>$\mathrm{res}:\mathrm{L}(\mathcal{X,Y})\to\mathcal{Y}\otimes\mathcal{X}$</span>, which transforms the matrix <span>$\rho$</span> into a vector row by row. More precisely, for dyadic operators <span>$|\psi\rangle\langle\phi|$</span>, where <span>$|\psi\rangle \in \mathcal{Y}$</span>, <span>$|\phi\rangle \in \mathcal{X}$</span> the operation <span>$\mathrm{res}$</span> is defined as <span>$\mathrm{res}(|\psi\rangle\langle\phi|)=|\psi\rangle|\overline{\phi}\rangle$</span> and can be uniquely extend to the whole space <span>$\mathrm{L}(\mathcal{X,Y})$</span> by linearity.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; res(ketbra(1,2,2))</code><code class="nohighlight hljs ansi" style="display:block;">4-element reshape(transpose(::Matrix{ComplexF64}), 4) with eltype ComplexF64:
 0.0 + 0.0im
 1.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im</code></pre><p>The inverse operation to <span>$\mathrm{res}$</span> is <span>$\mathrm{unres}:\mathcal{Y}\otimes\mathcal{X}\to \mathrm{L}(\mathcal{X,Y}) $, which transforms the vector into a matrix. It is defined as the unique linear mapping satisfying $\rho=\mathrm{unres}(\mathrm{res}(\rho))$</span>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; unres(res(ketbra(1,2,2)))</code><code class="nohighlight hljs ansi" style="display:block;">2×2 transpose(reshape(transpose(::Matrix{ComplexF64}), 2, 2)) with eltype ComplexF64:
 0.0+0.0im  1.0+0.0im
 0.0+0.0im  0.0+0.0im</code></pre><p>Let us recall that trace is a mapping <span>$\mathrm{Tr}:\mathrm{L}(\mathcal{X})\to \mathbb{C},$</span> given by <span>$\mathrm{Tr}:\rho\mapsto\sum_{i=1}^{\mathrm{dim}(\mathcal{X})}\langle e_i|\rho|e_i\rangle$</span>, where <span>$\{|e_i\rangle \}$</span> is an orthonormal basis of <span>$\mathcal{X}$</span>. According to this, <em>partial trace</em> is a mapping <span>$\mathrm{Tr}_{\mathcal{X}}: \mathrm{L}(\mathcal{X}\otimes\mathcal{Y}) \to \mathrm{L}(\mathcal{Y})$</span> such that <span>$\mathrm{Tr}_{\mathcal{X}}: \rho_A\otimes \rho_B \mapsto \rho_B \mathrm{Tr}(\rho_A)$</span>, where <span>$\rho_A\in \mathrm{L}(\mathcal{X})$</span>, <span>$\rho_B\in \mathrm{L}(\mathcal{Y})$</span>. As this is a linear map, it may be uniquely extended to the case of operators which are not in a tensor product form.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ρ = [0.25 0.25im; -0.25im 0.75]</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{ComplexF64}:
 0.25+0.0im    0.0+0.25im
 -0.0-0.25im  0.75+0.0im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; σ = [0.4 0.1im; -0.1im 0.6]</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{ComplexF64}:
  0.4+0.0im  0.0+0.1im
 -0.0-0.1im  0.6+0.0im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ptrace(ρ ⊗ σ, [2, 2], [2])</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{ComplexF64}:
 0.25+0.0im    0.0+0.25im
  0.0-0.25im  0.75+0.0im</code></pre><p>Matrix transposition is a mapping <span>${}^T:\mathrm{L}(\mathcal{X,Y}) \to \mathrm{L}(\mathcal{Y,X})$</span> such that <span>$\left(\rho^T \right)_{ij} = \rho_{ji}$</span>, where <span>$\rho_{ij}$</span> is a <span>$i$</span>-th row, <span>$j$</span>-th column element of matrix <span>$\rho$</span>. Following this, we may introduce \emph{partial transposition} <span>${}^{\Gamma_B}: \mathrm{L}(\mathcal{X}_A \otimes \mathcal{X}_B, \mathcal{Y}_A \otimes \mathcal{Y}_B) \to \mathrm{L}(\mathcal{X}_A \otimes \mathcal{Y}_B, \mathcal{Y}_A \otimes \mathcal{X}_B)$</span>, which for a product state <span>$\rho_A\otimes\rho_B$</span> is given by <span>${}^{\Gamma_B}: \rho_A\otimes\rho_B\mapsto\rho_A\otimes\rho_B^T$</span>. The definition of partial transposition can be uniquely extended for all operators from linearity.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ptranspose(ρ ⊗ σ, [2, 2], [1])</code><code class="nohighlight hljs ansi" style="display:block;">4×4 Matrix{ComplexF64}:
   0.1+0.0im       0.0+0.025im     0.0-0.1im    0.025-0.0im
   0.0-0.025im    0.15+0.0im    -0.025+0.0im      0.0-0.15im
   0.0+0.1im    -0.025+0.0im       0.3+0.0im      0.0+0.075im
 0.025-0.0im       0.0+0.15im      0.0-0.075im   0.45+0.0im</code></pre><p>For given multiindexed matrix <span>$\rho_{(m,\mu),(n,\nu)}=\langle m \mu|\rho|n \nu\rangle$</span>, the reshuffle operation is defined as <span>$\rho^R_{(m,\mu),(n,\nu)}=\rho_{(m,n),(\mu,\nu)}$</span>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; reshuffle(ρ ⊗ σ)</code><code class="nohighlight hljs ansi" style="display:block;">4×4 Matrix{ComplexF64}:
 0.1+0.0im     0.0+0.025im     0.0-0.025im  0.15+0.0im
 0.0+0.1im  -0.025+0.0im     0.025-0.0im     0.0+0.15im
 0.0-0.1im   0.025-0.0im    -0.025+0.0im     0.0-0.15im
 0.3+0.0im     0.0+0.075im     0.0-0.075im  0.45+0.0im</code></pre><h2 id="Channels"><a class="docs-heading-anchor" href="#Channels">Channels</a><a id="Channels-1"></a><a class="docs-heading-anchor-permalink" href="#Channels" title="Permalink"></a></h2><p>Physical transformations of quantum states into quantum states are called quantum channels <em>i.e.</em> linear Completely Positive Trace Preserving (CP-TP) transformations. Probabilistic transformations of quantum states are called quantum operations and mathematically they are defined as linear Completely Positive Trace Non-increasing (CP-TNI) maps. For the sake of simplicity we will refer to both CP-TP and CP-TNI maps as quantum channels when it will not cause confusion.</p><p>There exists various representations of quantum channels such as:</p><ul><li>Kraus operators,</li><li>natural representation, also called superoperator representation,</li><li>Stinespring representation,</li><li>Choi-Jamiołkowski matrices, sometimes called dynamical matrices.</li></ul><p>The product of superoperators <span>$\Phi_1\in \mathrm{T}(\mathcal{X}_1,\mathcal{Y}_1)$</span>, <span>$\Phi_2\in \mathrm{T}(\mathcal{X}_2,\mathcal{Y}_2)$</span> is a mapping <span>$\Phi_1\otimes\Phi_2\in T(\mathcal{X}_1\otimes\mathcal{X}_2,\mathcal{Y}_1\otimes\mathcal{Y}_2)$</span> that satisfies <span>$(\Phi_1\otimes\Phi_2)(\rho_1\otimes\rho_2)=\Phi_1(\rho_1)\otimes\Phi_2(\rho_2)$</span>. For the operators that are not in a tensor product form this notion can be uniquely extended from linearity.</p><p>According to Kraus&#39; theorem, any completely positive trace-preserving (CP-TP) map <span>$\Phi$</span> can always be written as <span>$\Phi(\rho)=\sum_{i=1}^r K_i \rho K_i^\dagger$</span> for some set of operators <span>$\{K_i\}_{i=1}^r$</span> satisfying <span>$\sum_{i=1}^r K_i^\dagger K_i = \mathbb{I}_\mathcal{X}$</span>, where <span>$r$</span> is the rank of superoperator <span>$\Phi$</span>.</p><p>Another way to represent the quantum channel is based on Choi-Jamiołkowski isomorphism. Consider mapping <span>$J:\mathrm{T}(\mathcal{X,Y})\to \mathrm{L}(\mathcal{Y}\otimes\mathcal{X})$</span> such that <span>$J(\Phi)=(\Phi\otimes\mathbb{I}_{\mathrm{L}(\mathcal{X})}) (\mathrm{res}(\mathbb{I}_{\mathcal{X}}) \mathrm{res}(\mathbb{I}_{\mathcal{X}})^\dagger)$</span>. Equivalently <span>$J(\Phi)=\sum_{i,j=1}^{\mathrm{dim(\mathcal{X})}}\Phi(|i\rangle\langle j|)\otimes|i\rangle\langle j|$</span>. The action of a superoperator in the Choi representation is given by <span>$\Phi(\rho)=\mathrm{Tr}_\mathcal{X}(J(\Phi)(\mathbb{I}_\mathcal{Y}\otimes\rho^T))$</span>.</p><p>The natural representation of a quantum channel <span>$\mathrm{T}(\mathcal{X}, \mathcal{Y})$</span> is a mapping <span>$\mathrm{res}(\rho) \mapsto \mathrm{res}(\Phi(\rho))$</span>. It is represented by a matrix <span>$K(\Phi) \in \mathrm{L}(\mathcal{X} \otimes \mathcal{X}, \mathcal{Y} \otimes \mathcal{Y})$</span> for which the following holds \begin{equation} K(\Phi) \mathrm{res}(\rho) = \mathrm{res}(\Phi(\rho)), \end{equation} for all <span>$\rho \in \mathrm{L}(\mathcal{X})$</span>.</p><p>Let <span>$\mathcal{X}, \mathcal{Y}$</span> and <span>$\mathcal{Z}$</span> be a complex Euclidean spaces. The action of the Stinespring representation of a quantum channel <span>$\Phi\in \mathrm{T}(\mathcal{X},\mathcal{Y})$</span> on a state <span>$\rho\in \mathrm{L}(\mathcal{X})$</span> is given by \begin{equation} \Phi(\rho)=\mathrm{Tr}_\mathcal{Z}(A\rho A^\dagger), \end{equation} where <span>$A\in\mathrm{L}(\mathcal{X},\mathcal{Y}\otimes\mathcal{Z})$</span>.</p><p>We now briefly describe the relationships among channel representations <a href="#refs_sc">[1]</a>. Let <span>$\Phi\in \mathrm{T}(\mathcal{X}, \mathcal{Y})$</span> be a quantum channel which can be written in the Kraus representation as <span>$\Phi(\rho)=\sum_{i=1}^r K_i \rho K_i^\dagger$</span>, where <span>$\{K_i\}_{i=1}^r$</span> are Kraus operators satisfying <span>$\sum_{i=1}^r K_i^\dagger K_i = \mathbb{I}_\mathcal{X}$</span>. According to this assumption, <span>$\Phi$</span> can be represented in</p><ul><li>Choi representation as <span>$J(\Phi)=\sum_{i=1}^r \mathrm{res}(K_i)\mathrm{res}(K_i^\dagger)$</span>,</li><li>natural representation as <span>$K(\Phi)=\sum_{i=1}^r K_i\otimes K_i^{*}$</span>,</li><li>Stinespring representation as <span>$\Phi(\rho)=\mathrm{Tr}_\mathcal{Z}(A\rho A^\dagger)$</span>,</li></ul><p>where <span>$A=\sum_{i=1}^r K_i\otimes |e_i\rangle$</span> and <span>$\mathcal{Z}=\mathbb{C}^r$</span>.</p><p>In <strong>QuantumInformation.jl</strong> states and channels are always represented in the computational basis therefore channels are stored in the memory as either vectors of matrices in case of Kraus operators or matrices in other cases. In <strong>QuantumInformation.jl</strong> quantum channels are represented by a set of types deriving from an abstract type <code>AbstractQuantumOperation{T}</code> where type parameter <code>T</code> should inherit from <code>AbstractMatrix{&lt;:Number}</code>. Every type inheriting from <code>AbstractQuantumOperation{T}</code> should contain fields <code>idim</code> and <code>odim</code> representing the dimension of input and output space of the quantum channel.</p><p>Two special types of channels are implemented: <code>UnitaryChannel</code> and <code>IdentityChannel</code> that can transform ket vectors into ket vectors.</p><h3 id="Constructors"><a class="docs-heading-anchor" href="#Constructors">Constructors</a><a id="Constructors-1"></a><a class="docs-heading-anchor-permalink" href="#Constructors" title="Permalink"></a></h3><p>Channel objects can be constructed from matrices that represent them, as shown in the following listing</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; γ=0.4</code><code class="nohighlight hljs ansi" style="display:block;">0.4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; K0 = Matrix([1 0; 0 sqrt(1-γ)])</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Float64}:
 1.0  0.0
 0.0  0.774597</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; K1 = Matrix([0 sqrt(γ); 0 0])</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{Float64}:
 0.0  0.632456
 0.0  0.0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Φ = KrausOperators([K0,K1])</code><code class="nohighlight hljs ansi" style="display:block;">KrausOperators{Matrix{Float64}}
    dimensions: (2, 2)
    [1.0 0.0; 0.0 0.7745966692414834]
    [0.0 0.6324555320336759; 0.0 0.0]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; iscptp(Φ)</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>There are no checks whether a matrix represents a valid CP-TP or CP-TNI map, because this kind of verification is costly and requires potentially expensive numerical computation. Function such as <code>iscptp()</code>, and <code>iscptni()</code> are provided to test properties of supposed quantum channel or quantum operation.</p><h3 id="Conversion"><a class="docs-heading-anchor" href="#Conversion">Conversion</a><a id="Conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion" title="Permalink"></a></h3><p>Conversions between all quantum channel types, <em>i.e.</em> these that derive from <code>AbstractQuantumOperation{T}</code> are implemented. The users are not limited by any single channel representation and can transform between representations they find the most efficient or suitable for their purpose.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Ψ1 = convert(SuperOperator{Matrix{ComplexF64}}, Φ)</code><code class="nohighlight hljs ansi" style="display:block;">SuperOperator{Matrix{ComplexF64}}
    dimensions: (2, 2)
    ComplexF64[1.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.4 + 0.0im; 0.0 + 0.0im 0.7745966692414834 + 0.0im 0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im 0.7745966692414834 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im 0.0 + 0.0im 0.6000000000000001 + 0.0im]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Ψ2 = convert(DynamicalMatrix{Matrix{Float64}}, Φ)</code><code class="nohighlight hljs ansi" style="display:block;">DynamicalMatrix{Matrix{Float64}}
    dimensions: (2, 2)
    [1.0 0.0 0.0 0.7745966692414834; 0.0 0.4 0.0 0.0; 0.0 0.0 0.0 0.0; 0.7745966692414834 0.0 0.0 0.6000000000000001]</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Ψ3 = convert(Stinespring{Matrix{Float64}}, Φ)</code><code class="nohighlight hljs ansi" style="display:block;">Stinespring{Matrix{Float64}}
    dimensions: (2, 2)
    [0.0 0.0; -1.8250120749944287e-8 0.0; … ; 0.0 0.0; 0.0 -0.7745966692414835]</code></pre><h3 id="Application"><a class="docs-heading-anchor" href="#Application">Application</a><a id="Application-1"></a><a class="docs-heading-anchor-permalink" href="#Application" title="Permalink"></a></h3><p>Channels can act on pure and mixed states represented by vectors and matrices respectively. Channels are callable and therefore mimic application of a function on a quantum state.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ρ1=ψ * ψ&#39;</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{ComplexF64}:
 0.5+0.0im  0.5+0.0im
 0.5+0.0im  0.5+0.0im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Φ(ρ1)</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{ComplexF64}:
      0.7+0.0im  0.387298+0.0im
 0.387298+0.0im       0.3+0.0im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Ψ1(ρ1)</code><code class="nohighlight hljs ansi" style="display:block;">2×2 transpose(::Matrix{ComplexF64}) with eltype ComplexF64:
      0.7+0.0im  0.387298+0.0im
 0.387298+0.0im       0.3+0.0im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Φ(ψ)</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{ComplexF64}:
      0.7+0.0im  0.387298+0.0im
 0.387298+0.0im       0.3+0.0im</code></pre><h3 id="Composition"><a class="docs-heading-anchor" href="#Composition">Composition</a><a id="Composition-1"></a><a class="docs-heading-anchor-permalink" href="#Composition" title="Permalink"></a></h3><p>Channels can be composed in parallel or in sequence. Composition in parallel is done using <code>kron()</code> function or the overloaded <span>$\otimes$</span> operator. Composition in sequence can be done in two ways either by using Julia built-in function composition operator <span>$(f\circ g)(\cdot)=f(g)(\cdot)$</span> or by using multiplication of objects inheriting from <code>AbstractQuantumOperation{T}</code> abstract type.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ρ2=ϕ * ϕ&#39;</code><code class="nohighlight hljs ansi" style="display:block;">2×2 Matrix{ComplexF64}:
     0.25+0.0im  0.433013+0.0im
 0.433013+0.0im      0.75+0.0im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (Φ⊗Φ)(ρ1⊗ρ2)</code><code class="nohighlight hljs ansi" style="display:block;">4×4 Matrix{ComplexF64}:
    0.385+0.0im  0.234787+0.0im  0.213014+0.0im  0.129904+0.0im
 0.234787+0.0im     0.315+0.0im  0.129904+0.0im  0.174284+0.0im
 0.213014+0.0im  0.129904+0.0im     0.165+0.0im  0.100623+0.0im
 0.129904+0.0im  0.174284+0.0im  0.100623+0.0im     0.135+0.0im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; (Ψ1∘Ψ2)(ρ1)</code><code class="nohighlight hljs ansi" style="display:block;">2×2 transpose(::Matrix{ComplexF64}) with eltype ComplexF64:
 0.82+0.0im   0.3+0.0im
  0.3+0.0im  0.18+0.0im</code></pre><h2 id="refs_sc"><a class="docs-heading-anchor" href="#refs_sc">References</a><a id="refs_sc-1"></a><a class="docs-heading-anchor-permalink" href="#refs_sc" title="Permalink"></a></h2><p>[1] J. Watrous, <em>The Theory of Quantum Information</em>, Cambridge University Press (2018).</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../vectors/">« Linear algebra in Julia</a><a class="docs-footer-nextpage" href="../functionals/">Functionals »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 2 May 2023 11:09">Tuesday 2 May 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
